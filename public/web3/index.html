<!doctype html><html lang=en dir=auto data-theme=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Web3 技术探究 | 0907 WORLD</title>
<meta name=keywords content><meta name=description content="Web3 技术探究 - 0907 WORLD"><meta name=author content="Guangyang Zhong"><link rel=canonical href=http://localhost:1313/web3/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/images/0907world_icon.webp><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/images/0907world_icon.webp><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/images/0907world_icon.webp><link rel=apple-touch-icon href=http://localhost:1313/images/0907world_icon.webp><link rel=mask-icon href=http://localhost:1313/images/0907world_icon.webp><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://localhost:1313/web3/index.xml title=rss><link rel=alternate hreflang=en href=http://localhost:1313/web3/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://localhost:1313/web3/"><meta property="og:site_name" content="0907 WORLD"><meta property="og:title" content="Web3 技术探究"><meta property="og:description" content="ExampleSite description"><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Web3 技术探究"><meta name=twitter:description content="ExampleSite description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Web3 技术探究","item":"http://localhost:1313/web3/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="0907 WORLD (Alt + H)"><img src=http://localhost:1313/images/0907world_icon.webp alt aria-label=logo height=35>0907 WORLD</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://localhost:1313/web3/ title=Web3><span class=active>Web3</span></a></li><li><a href=http://localhost:1313/uestc/ title=UESTC><span>UESTC</span></a></li><li><a href=http://localhost:1313/findings/ title=Findings><span>Findings</span></a></li><li><a href=http://localhost:1313/projects/ title=Projects><span>Projects</span></a></li><li><a href=http://localhost:1313/toolkits/ title=Toolkits><span>Toolkits</span></a></li><li><a href=http://uestc.0907world.cn:3000 title=World><span>World</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a></div><h1>Web3 技术探究
<a href=/web3/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><figure class=entry-cover><img loading=lazy src=http://localhost:1313/covers/Web3_cover.webp alt></figure><header class=entry-header><h2 class=entry-hint-parent>Web3 简介</h2></header><div class=entry-content><p>Welcome to Web3! Web3代表互联网下一个时代以区块链为核心实现去中心化用户掌控数据和资产通过智能合约自动化交互摆脱中心化平台控制
security Web3安全聚焦预防黑客攻击和漏洞利用
采用多层防御策略包括智能合约审计访问控制实时监控
使用Slither Mythril检测重入攻击整数溢出权限问题
最佳实践强调私钥管理多签名钱包紧急暂停机制
2025年主要威胁包括闪贷治理攻击跨链桥漏洞钓鱼攻击
强调安全即代码从设计阶段整合形式验证AI驱动监控
开源库OpenZeppelin提供安全合约模板减少常见错误
机构级项目需持续审计漏洞赏金计划构建信任
wallet 钱包是Web3入口管理私钥和资产交互
分为热钱包和冷钱包
热钱包如MetaMask浏览器扩展方便dApp连接但易受网络攻击
冷钱包包括Ledger硬件钱包和纸钱包离线存储更安全适合大额持有
非托管钱包用户完全控制密钥
托管钱包如Coinbase简化但依赖平台
ERC-4337账户抽象提升用户体验支持社交恢复气体赞助
多链钱包如Rainbow支持Layer2降低费用
安全提示必须使用硬件签名绝不泄露种子短语定期备份
eip 👉 EIP 笔记合集
EIP是以太坊改进提案标准化平台变更
涵盖核心协议客户端API合约规范
任何人可提交草案经社区讨论编辑审查进入最终状态
核心EIP需全网共识可能引发硬分叉
如EIP-1559引入基础费市场
ERC是EIP子集专注应用层标准
EIP过程确保透明包容
从草稿到最后调用再到最终实施
EIP-4844引入blob数据大幅降低Layer2成本
未来EIP聚焦可扩展性隐私如Verkle树
erc ERC是以太坊请求评论定义代币和应用标准
ERC20用于可互换代币如USDT支持转移批准余额查询
ERC721创建非同质化代币NFT唯一标识所有权如CryptoKitties
ERC1155多代币标准单一合约管理可互换非同质化半同质化资产
高效批量转移节省气体适用于游戏物品票务
这些标准确保全生态互操作性
开发者可直接构建兼容项目
ERC20主导DeFi
ERC721推动NFT市场
ERC1155优化复杂用例
codeLanuage 智能合约语言最终编译为EVM字节码
Solidity主流类JavaScript支持继承修饰符库生态最丰富
Vyper Python风格故意去除继承无限循环提升可审计性安全性
Yul中间语言用于精细气体优化
Rust主要用于Solana非EVM链
Ethereum生态仍以Solidity和Vyper为主
学习Solidity推荐从Remix IDE开始
Vyper强调人类可读代码减少攻击面
选择语言取决于项目复杂度和安全优先级
evm EVM是以太坊虚拟机去中心化计算引擎
执行智能合约字节码采用栈基架构深度1024
每操作码消耗气体防止滥用
Turing完备支持任意逻辑但有气体上限避免无限循环
EVM负责状态转换更新账户余额存储
所有节点一致执行保证确定性隔离
兼容链如Polygon Arbitrum共享EVM实现无缝移植
未来升级EOF引入容器化代码提升效率
EVM是整个以太坊生态的计算核心
...</p></div><footer class=entry-footer><span title='2025-11-20 00:00:00 +0000 UTC'>November 20, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>86 words</span>&nbsp;·&nbsp;<span>Guangyang Zhong</span></footer><a class=entry-link aria-label="post link to Web3 简介" href=http://localhost:1313/web3/intro/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>安全审计 笔记合集</h2></header><div class=entry-content><p>简介 Web3，作为一个以去中心化为核心理念的新一代互联网范式，其基石建立在区块链技术——一个不可篡改、透明公开的分布式账本之上。这个账本通过精密的共识机制确保网络参与者能够在无需相互信任的情况下达成一致，这无疑是革命性的
然而，这种“不可篡改”的特性是一把双刃剑。一旦智能合约部署上链，其代码逻辑便永久固化，任何潜在的错误、漏洞或设计缺陷都将被永恒记录，并可能被恶意利用，造成无法挽回的资产损失。在传统互联网中，一个漏洞可以通过“打补丁”快速修复；在区块链世界，修复往往意味着复杂的迁移、昂贵的社区沟通，乃至彻底的失败。因此，“安全前置” 的理念在这里被提升到了前所未有的高度
安全审计（Security Audit）正是在这种严苛环境下应运而生的核心质量保障手段。它不再是一种可选的成本，而是智能合约开发生命周期中不可或缺的、防御性的关键环节。一个严谨、深入的审计过程，是项目对自身代码负责、对用户资产负责的最重要体现
👉 0907 审计模板仓库
👉 0907 审计报告仓库
高层概述 ( 什么是安全审计/智能合约审计？ ) 当人们提到"审计"时，通常指的是安全审查（Security Review）。这是对智能合约代码进行系统性、专业性的安全检查过程，旨在识别潜在的安全漏洞、逻辑错误和设计缺陷。
审计的局限性 There is no silver bullet ( 感兴趣的同学可以去搜一下该词的意思 ) to auditing：需要明确的是，审计并非万能的解决方案。即使经过最严格的审计，智能合约仍可能存在：
未被发现的复杂逻辑漏洞 经济模型的长尾风险 与外部协议集成时的未知交互风险 编译器或区块链底层本身的潜在问题 一次审计只能提供特定时间点的安全快照，无法保证永久的绝对安全。
安全审计的三个阶段 第一阶段：初步审查（Initial Review） 1. 范围界定（Scoping） 确定审计的具体范围：哪些合约、哪些功能 明确审计目标、时间线和交付物 了解协议的业务逻辑和设计意图 2. 侦察（Reconnaissance） 初步代码阅读和理解架构 识别关键组件和依赖关系 梳理权限模型和资金流向 3. 漏洞识别（Vulnerability Identification） 系统性检查各类安全漏洞 结合自动化工具和人工审查 从攻击者角度思考可能的攻击向量 4. 报告（Reporting） 详细记录发现的每个问题 按严重程度分类（危急、高危、中危、低危） 提供具体的修复建议和代码示例 第二阶段：协议修复与验证 1. 修复问题（Protocol Fixes） 开发团队根据审计报告修复漏洞 可能需要重新设计部分逻辑 确保修复方案不引入新的问题 2. 重新测试与添加测试（Retests and Adds Tests） 审计团队验证修复的有效性 为修复的部分添加专门的测试用例 确保修复后的代码仍能满足业务需求 第三阶段：缓解措施审查（Mitigation Review） 1. 侦察（Reconnaissance） 审查所有修复的代码变更 理解修复方案的安全影响 2. 漏洞识别（Vulnerability Identification） 确认原始漏洞已被彻底修复 检查修复是否引入了新的攻击面 3. 报告（Reporting） 提供最终的审计结论 确认所有高风险问题已解决 给出部署前的最终建议 智能合约开发生命周期 1. 规划与设计（Plan & Design） 需求分析和功能规划 架构设计和模式选择 安全考虑融入设计阶段（Security by Design） 经济模型和激励机制的数学验证 2. 开发与测试（Develop & Test） 编写合约代码和单元测试 集成测试和端到端测试 模糊测试（Fuzzing）和差异化测试 测试网部署和模拟攻击 3. 智能合约审计与部署后规划 这不仅仅是一个步骤，而是一个包含多个子阶段的综合过程（类似于传统软件开发生命周期SDLC，但具有区块链特有的安全考量）：
...</p></div><footer class=entry-footer><span title='2025-08-16 00:00:00 +0000 UTC'>August 16, 2025</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>431 words</span>&nbsp;·&nbsp;<span>Guangyang Zhong</span></footer><a class=entry-link aria-label="post link to 安全审计 笔记合集" href=http://localhost:1313/web3/security/intro/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>EIP 笔记合集</h2></header><div class=entry-content><p>EIP 索引总览 这里收录所有值得单独成文的里程碑级EIP
每篇深度拆解一份EIP的诞生背景技术细节安全影响落地历程社区争议及后续演进
点击标题直达对应专文
简介 EIP（Ethereum Improvement Proposal）是以太坊改进提案
任何人都能提交的标准化文档
驱动以太坊从创世区块到今天的唯一正式机制
ERC只是EIP的应用层子集
所有硬分叉升级Layer2变革账户抽象都源于EIP
账户抽象时代 EIP-4337 智能合约账户 EIP-7702 新账户抽象终极方案（2025进行中）（待撰写） 费用市场与通缩 EIP-1559 基础费燃烧：让ETH成为超声波货币（待撰写） EIP-4844 Proto-Danksharding：Rollup费用暴跌90%（待撰写） EIP-7514 减缓质押增长：保护去中心化（待撰写） 质押与提款 EIP-4895 质押提款：上海升级核心（待撰写） EIP-7002 部分提款与主动退出（待撰写） EIP-6110 链上质押存款（待撰写） EVM与执行层未来 EIP-7691 EOF：EVM容器化革命（2026目标）（待撰写） EIP-7623 提高CALLDATA成本为Danksharding铺路（待撰写） EIP-4444 历史数据过期机制（待撰写） EIP-5656 MCOPY指令：降低内存拷贝成本（待撰写） 数据可用性与Layer2 EIP-4844 Blob交易与Danksharding路线图（待撰写） EIP-7594 PeerDAS：对等数据可用性采样（待撰写） EIP-6465/6466 Blob历史过期方案（待撰写） 其他正在关注的EIP EIP-7732 EIP-7702+ERC-7730安全增强版（待撰写） EIP-712 类型化结构化数据签名：链上安全签名的金标准（待撰写） EIP-2537 BLS预编译：加速零知识证明（待撰写） EIP-5920 PAY opcode：原生转账新方式（待撰写） EIP-6780 自毁仅限创建交易：提升状态管理（待撰写） EIP-2612 Permit：ERC20 的无gas授权革命（待撰写） 更多EIP专文持续更新中
目前仅EIP-4337已完稿，其余陆续放出
每一篇都是以太坊进化史的真实注脚</p></div><footer class=entry-footer><span title='2024-08-16 00:00:00 +0000 UTC'>August 16, 2024</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>66 words</span>&nbsp;·&nbsp;<span>Guangyang Zhong</span></footer><a class=entry-link aria-label="post link to EIP 笔记合集" href=http://localhost:1313/web3/eip/intro/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DeFi 笔记合集</h2></header><div class=entry-content><p>简介 去中心化金融旨在通过区块链与智能合约，构建一个开放、透明、可组合的金融服务生态系统。本合集从核心协议原理出发，系统梳理各赛道的运行机制、风险模型与演进趋势。
Lending DeFi借贷协议允许用户无需中介即可存入资产获取收益，或超额抵押资产借出其他资产。其核心机制包括资金池、利率模型、清算机制以及治理代币经济学
Flash Loan 👉 Flash Loan 闪电贷 Liquid Staking 流动性质押协议允许用户在参与区块链共识（如质押ETH）的同时，获得代表质押头寸的流动性衍生代币（如stETH），从而解决质押资产流动性锁定的问题
DEX 👉 DEX 经典概念 去中心化交易所（DEX）通过自动做市商机制，允许用户直接在链上交易加密资产。核心在于流动性池、恒定乘积等定价公式、手续费激励以及无常损失管理
RWA 现实世界资产旨在将传统金融资产（如国债、信贷、不动产）通过代币化引入区块链，为DeFi生态系统提供具有实际价值支撑的收益资产，并面临合规、托管与法律映射等独特挑战</p></div><footer class=entry-footer><span title='2025-08-16 00:00:00 +0000 UTC'>August 16, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>20 words</span>&nbsp;·&nbsp;<span>Guangyang Zhong</span></footer><a class=entry-link aria-label="post link to DeFi 笔记合集" href=http://localhost:1313/web3/defi/intro/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Web3 开发框架合集</h2></header><div class=entry-content><p>简介 foundry 👉 foundry 使用指南
hardhat</p></div><footer class=entry-footer><span title='2025-08-18 00:00:00 +0000 UTC'>August 18, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>6 words</span>&nbsp;·&nbsp;<span>Guangyang Zhong</span></footer><a class=entry-link aria-label="post link to Web3 开发框架合集" href=http://localhost:1313/web3/framework/intro/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DEX 经典概念</h2></header><div class=entry-content><p>简介 AMM（Automated Market Maker，自动做市商）是一类无需订单簿、无需对手方撮合就能完成资产交换的机制。它通过一条数学定价曲线（例如最经典的恒定乘积公式 x * y = k）来确定池中两种资产的价格与兑换比例
交易者与 AMM 交互时，并不是与某个具体对手方进行买卖，而是与池子本身交易：
当交易者往池子中加入一种资产时，池子的储备量发生变化 定价曲线根据新储备自动给出另一种资产能取出的数量 由此实现“自动化报价”和“自动化执行” 1. 基本概念与不变式 AMM 的核心思想：用一个自动化的数学不变式替代传统的订单簿，以池内储备（reserves）决定交易价格与数量。 最经典的不变式（恒定乘积）为： x y = k 其中 x、y 为池内两种资产的数量（reserve of X, reserve of Y），k 为常数（在无手续费的理想情况下保持不变）。
交易通过改变 x 或 y 的值来完成，新的 x 和 y 必须满足不变式（考虑手续费时，换入量先扣手续费再作用于不变式） 2. 交易定价与交换公式（恒定乘积，含手续费） 设池初始为 x（Token X）与 y（Token Y），不变式 k = x * y。有交易者向池中放入 Δx（交易量），手续费比例为 f（例如 0.003 = 0.3%）。实际用于保持不变式的增量为：
Δ x _ e f f = Δ x ( 1 - f ) 新的储备为：
...</p></div><footer class=entry-footer><span title='2025-08-20 00:00:00 +0000 UTC'>August 20, 2025</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1128 words</span>&nbsp;·&nbsp;<span>Guangyang Zhong</span></footer><a class=entry-link aria-label="post link to DEX 经典概念" href=http://localhost:1313/web3/defi/dex/dex/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Flash Loan 闪电贷</h2></header><div class=entry-content><p>简介 闪电贷（Flash Loan） 是一种在单笔区块链交易内借入资产、使用资产并在同一交易内归还借款（含手续费）的借贷模式。核心特点是 “原子性”：借款、使用和还款必须在同一笔交易内完成，否则交易会回滚，借款不会生效。
这种机制使得借款人在不提供抵押的情况下临时动用大量资产，用于套利、清算、头寸迁移等操作；同时也被用于发动复杂的攻击（如操纵价格、闪电清算等）。
原理与执行流程 典型单笔闪电贷交易包含三步（原子性）：
借款（Borrow） 在交易开始阶段通过闪电贷提供方（Lending Pool/Router）请求借入若干资产。
使用（Use） 在同一交易中，用借入资金执行任意链上操作，例如在不同 DEX 之间套利、进行清算、调整抵押头寸、执行跨协议操作等。
还款（Repay） 在交易结束前，将借入金额加上借贷方要求的手续费一并偿还给闪电贷提供方。如果无法偿还（余额不足或逻辑失败），整笔交易 revert，等同于“未发生”。
关键点：闪电贷的安全性与“回滚语义”绑定；若中间步骤出错，借贷不会被实际放出和使用。
常见闪电贷提供方 Aave（flashLoan / flashLoanSimple 接口） DyDx（Solo or v3） Uniswap（flash swap：允许先输出资产，再在同一交易内履约） Balancer / Curve / 其它支持 flash 的池子 （实现细节与接口在不同协议间不同） 典型用途（Use cases） 跨 DEX 套利：利用不同交易所价格差套利，套利收益用于偿还贷款并留盈利 清算（Liquidation）：借资产替别人清算欠债（避免自己需提前持有资产） 头寸迁移 / 债务重组：一笔交易内把抵押品替换、债务迁移到另一个协议或仓位 杠杆构建 / 扩展：临时放大仓位用于策略 原子化多步操作：把多个必须同时完成的步骤整合为一笔交易，避免中间状态风险 代码示例 // SPDX-License-Identifier: AGPL-3.0-only pragma solidity 0.8.20; import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import { AssetToken } from "./AssetToken.sol"; import { IERC20, IERC20Metadata } from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { Oracle } from "./Oracle.sol"; interface IFlashLoanReceiver { function executeOperation(address token, uint256 amount, uint256 fee, address initiator, bytes calldata params) external; } contract ThunderLoan is Ownable, Oracle { using SafeERC20 for IERC20; /*////////////////////////////////////////////////////////////// STATE VARIABLES //////////////////////////////////////////////////////////////*/ mapping(IERC20 => AssetToken) public s_tokenToAssetToken; mapping(IERC20 => bool) private s_currentlyFlashLoaning; uint256 private constant FEE_PRECISION = 1e18; uint256 private s_flashLoanFee = 3e15; // 0.3% /*////////////////////////////////////////////////////////////// EVENTS //////////////////////////////////////////////////////////////*/ event Deposit(address indexed account, IERC20 indexed token, uint256 amount); event Withdraw(address indexed account, IERC20 indexed token, uint256 amount); event FlashLoan(address indexed receiver, IERC20 indexed token, uint256 amount, uint256 fee); event TokenAllowed(IERC20 indexed token, bool allowed); /*////////////////////////////////////////////////////////////// MODIFIERS //////////////////////////////////////////////////////////////*/ modifier notZero(uint256 amount) { require(amount > 0, "Amount cannot be zero"); _; } modifier allowedToken(IERC20 token) { require(address(s_tokenToAssetToken[token]) != address(0), "Token not allowed"); _; } /*////////////////////////////////////////////////////////////// EXTERNAL FUNCTIONS //////////////////////////////////////////////////////////////*/ constructor(address oracle) Oracle(oracle) Ownable(msg.sender) {} function deposit(IERC20 token, uint256 amount) external notZero(amount) allowedToken(token) { AssetToken assetToken = s_tokenToAssetToken[token]; // 计算应铸造的资产代币数量 uint256 mintAmount = (amount * FEE_PRECISION) / assetToken.getExchangeRate(); // 铸造资产代币给用户 assetToken.mint(msg.sender, mintAmount); // 更新汇率（包含手续费） assetToken.updateExchangeRate(calculateFee(token, amount)); // 将底层代币转移到资产代币合约 token.safeTransferFrom(msg.sender, address(assetToken), amount); emit Deposit(msg.sender, token, amount); } function withdraw(IERC20 token, uint256 assetAmount) external notZero(assetAmount) allowedToken(token) { AssetToken assetToken = s_tokenToAssetToken[token]; // 计算可取回的底层代币数量 uint256 underlyingAmount = (assetAmount * assetToken.getExchangeRate()) / FEE_PRECISION; // 销毁用户的资产代币 assetToken.burn(msg.sender, assetAmount); // 将底层代币转给用户 assetToken.transferUnderlyingTo(msg.sender, underlyingAmount); emit Withdraw(msg.sender, token, underlyingAmount); } function flashLoan( address receiver, IERC20 token, uint256 amount, bytes calldata params ) external notZero(amount) allowedToken(token) { AssetToken assetToken = s_tokenToAssetToken[token]; // 检查合约余额是否足够 uint256 poolBalance = token.balanceOf(address(assetToken)); require(amount &lt;= poolBalance, "Insufficient pool balance"); // 检查接收者是合约 require(receiver.code.length > 0, "Receiver must be contract"); // 计算手续费 uint256 fee = calculateFee(token, amount); // 更新汇率 assetToken.updateExchangeRate(fee); // 标记为正在闪电贷 s_currentlyFlashLoaning[token] = true; // 将资金转给接收者 assetToken.transferUnderlyingTo(receiver, amount); // 调用接收者的回调函数 IFlashLoanReceiver(receiver).executeOperation( address(token), amount, fee, msg.sender, params ); // 验证还款 uint256 newBalance = token.balanceOf(address(assetToken)); require(newBalance >= poolBalance + fee, "Flash loan not repaid"); // 重置闪电贷状态 s_currentlyFlashLoaning[token] = false; emit FlashLoan(receiver, token, amount, fee); } function repay(IERC20 token, uint256 amount) external { require(s_currentlyFlashLoaning[token], "Not in flash loan"); token.safeTransferFrom(msg.sender, address(s_tokenToAssetToken[token]), amount); } /*////////////////////////////////////////////////////////////// ADMIN FUNCTIONS //////////////////////////////////////////////////////////////*/ function setAllowedToken(IERC20 token, bool allowed) external onlyOwner { if (allowed) { require(address(s_tokenToAssetToken[token]) == address(0), "Already allowed"); string memory name = string.concat("ThunderLoan ", IERC20Metadata(address(token)).name()); string memory symbol = string.concat("tl", IERC20Metadata(address(token)).symbol()); AssetToken assetToken = new AssetToken(address(this), token, name, symbol); s_tokenToAssetToken[token] = assetToken; } else { delete s_tokenToAssetToken[token]; } emit TokenAllowed(token, allowed); } function setFlashLoanFee(uint256 newFee) external onlyOwner { require(newFee &lt;= FEE_PRECISION, "Fee too high"); s_flashLoanFee = newFee; } /*////////////////////////////////////////////////////////////// VIEW FUNCTIONS //////////////////////////////////////////////////////////////*/ function calculateFee(IERC20 token, uint256 amount) public view returns (uint256) { uint256 tokenValue = (amount * getPriceInWeth(address(token))) / FEE_PRECISION; return (tokenValue * s_flashLoanFee) / FEE_PRECISION; } function isAllowedToken(IERC20 token) public view returns (bool) { return address(s_tokenToAssetToken[token]) != address(0); } function getFlashLoanFee() external view returns (uint256) { return s_flashLoanFee; } } 经济可行性与可行性检查 在执行闪电贷策略前需判断经济可行性，常见校验条目：
...</p></div><footer class=entry-footer><span title='2025-08-20 00:00:00 +0000 UTC'>August 20, 2025</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>549 words</span>&nbsp;·&nbsp;<span>Guangyang Zhong</span></footer><a class=entry-link aria-label="post link to Flash Loan 闪电贷" href=http://localhost:1313/web3/defi/lending/flashloan/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>foundry Forge 使用指南</h2></header><div class=entry-content><p>简介 Forge 是 Foundry 的核心组件，用于编写、运行和调试 Solidity 智能合约测试，支持单元测试、模糊测试（fuzz testing）和不变量测试（invariant testing）。它允许开发者在 Solidity 中直接编写测试，而无需切换到其他语言。Forge 通过 forge test 命令运行测试，并提供丰富的作弊码（cheatcodes）来模拟各种场景
测试类型 Stateless Test 无状态测试（Stateless Test）是指每个测试函数独立运行，状态在每次调用后重置。这包括标准的单元测试和无状态模糊测试。在无状态测试中，Forge 会为每个测试函数创建一个干净的环境，确保测试之间互不干扰。这适合测试单一函数的行为或特定输入输出
Stateful Test 有状态测试（Stateful Test）允许测试在多个函数调用序列中保持状态，通常用于不变量测试（Invariant Testing）。在这种测试中，Forge 会生成随机调用序列，并在每个调用后检查不变量是否成立。这有助于发现复杂协议中的逻辑错误，尤其是在多步交互场景下
forge 基础测试 文件目录与命名 Foundry 项目采用标准的目录结构，便于管理和测试：
src/：存放核心智能合约代码，例如 Contract.sol test/：存放测试合约，通常以 .t.sol 结尾，例如 Contract.t.sol。测试文件放在这里以便 Forge 自动识别 script/：存放部署脚本，例如 Deploy.s.sol lib/：存放依赖库，如 forge-std 或 OpenZeppelin foundry.toml：配置文件，用于设置测试参数、依赖等 命名规范：
测试合约文件名以 .t.sol 结尾 源合约文件名以 .sol 结尾 避免使用特殊字符，确保文件名描述性强 合约代码框架 Forge 测试合约必须继承自 forge-std/Test.sol 中的 Test 合约，这提供了断言、日志和作弊码功能。基本框架如下：
// SPDX-License-Identifier: MIT pragma solidity ^0.8.20; import "forge-std/Test.sol"; contract MyContractTest is Test { // 待测试合约实例 MyContract public myContract; // setUp 函数：在每个测试前运行，初始化状态 function setUp() public { myContract = new MyContract(); } // 测试函数：以 test 开头 function test_Example() public { // 测试逻辑 assertTrue(true); } } setUp()：可选，用于初始化合约或状态。 测试函数：必须以 test 开头，public 或 external 断言：使用 assertEq(a, b)、assertTrue(condition) 等 作弊码：如 vm.prank(address) 模拟调用者 forge 进阶测试 Fuzz Testing 模糊测试（Fuzz Testing）是一种 property based 测试，Forge 会生成随机输入来验证合约的通用行为。测试函数需至少有一个参数（如 uint256 amount），Forge 会自动将其视为 fuzz 测试，默认运行 256 次
...</p></div><footer class=entry-footer><span title='2025-08-20 00:00:00 +0000 UTC'>August 20, 2025</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>231 words</span>&nbsp;·&nbsp;<span>Guangyang Zhong</span></footer><a class=entry-link aria-label="post link to foundry Forge 使用指南" href=http://localhost:1313/web3/framework/foundry/forge/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=http://localhost:1313/covers/foundry.webp alt></figure><header class=entry-header><h2 class=entry-hint-parent>foundry 使用指南</h2></header><div class=entry-content><p>简介 入门指南 👉 foundry 入门指南
Forge 👉 foundry Forge 使用指南
Cast 👉 foundry Cast 使用指南
Anvil 👉 foundry Anvil 使用指南
Chisel 👉 foundry Chisel 使用指南
Configuration 👉 foundry 配置指南
Cheatcode 👉 foundry Cheatcode 使用指南</p></div><footer class=entry-footer><span title='2025-08-20 00:00:00 +0000 UTC'>August 20, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>34 words</span>&nbsp;·&nbsp;<span>Guangyang Zhong</span></footer><a class=entry-link aria-label="post link to foundry 使用指南" href=http://localhost:1313/web3/framework/foundry/intro/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>测试级漏洞合集</h2></header><div class=entry-content><p>简介 拒绝服务 ( Dos - Denial of Service ) 简要概述 DoS 攻击在智能合约中常出现于以下场景：
攻击者通过让某个必要操作持续失败，从而阻止整个合约继续执行关键流程（如奖励分发、批量提款、循环遍历列表等）。
典型示例： 合约在循环中向所有参与者发送 ETH，攻击者故意将自己的 fallback/receive 函数设计为 永远 revert，导致程序在遍历到攻击者地址时整个交易回滚，进而导致奖励分发/提款功能长期瘫痪
易受攻击模式：
function distribute() external { for (uint256 i = 0; i &lt; participants.length; i++) { address user = participants[i]; uint256 amount = rewards[user]; // 任意一次 transfer 失败，整个分发流程就会 revert payable(user).transfer(amount); } } 攻击者只需在列表中占据一个位置，即可长期阻塞整个流程。
改进方法 使用 Pull Payment 不再向用户“发送奖励”，而是让用户自己来“领取奖励”，这样单个用户的失败不会影响其他用户
function claim() external { uint256 amount = rewards[msg.sender]; require(amount > 0, "no reward"); // Effects（先修改状态） rewards[msg.sender] = 0; // Interactions（再转账） (bool ok, ) = payable(msg.sender).call{value: amount}(""); require(ok, "send failed"); } CEI 说明：
Checks：检查 reward 是否大于 0 Effects：先清零 reward 防止重入 Interactions：最后转账，不会阻塞其他用户 在必须 push 的场景中采用“非阻塞式分发” 避免因为某个地址转账失败而导致整个循环回滚
...</p></div><footer class=entry-footer><span title='2025-08-20 00:00:00 +0000 UTC'>August 20, 2025</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>1356 words</span>&nbsp;·&nbsp;<span>Guangyang Zhong</span></footer><a class=entry-link aria-label="post link to 测试级漏洞合集" href=http://localhost:1313/web3/security/vulnerability/tlv/></a></article><footer class=page-footer><nav class=pagination><a class=next href=http://localhost:1313/web3/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>0907 WORLD</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>