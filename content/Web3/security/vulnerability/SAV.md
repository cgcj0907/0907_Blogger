---
title: "静态分析漏洞合集"
date: 2025-08-20
draft: false
tags: ["Web3", "security", "vulnerability"]
showToc: true
---

# 简介

## 整数溢出（Integer Overflow）

### 简要概述
在Solidity中，无符号整数（如`uint256`）在加/减/乘除运算时，若超出类型范围（例如`uint256`最大值为2^256-1），会发生“回绕”（overflow/underflow），导致意外结果，如余额错误计算、资金无限铸币或丢失。在Solidity <0.8.0版本中无内置检查，易被利用

**典型易受攻击模式**：

```solidity
// 错误示范（无溢出检查）
pragma solidity ^0.7.0;

contract VulnerableToken {
    mapping(address => uint256) public balances;

    function transfer(address to, uint256 amount) external {
        require(balances[msg.sender] >= amount);
        balances[msg.sender] -= amount; // <-- 可能下溢（underflow）
        balances[to] += amount; // <-- 可能上溢（overflow）
    }
}
```

攻击者可利用下溢：若余额为0，减去1会回绕成最大值，导致盗取巨额资金

### 改进方法
升级到Solidity ^0.8.0+（内置溢出检查，会revert），或使用SafeMath库进行安全运算

示例：
```solidity
// 使用内置检查（Solidity ^0.8.0）
pragma solidity ^0.8.0;

contract SecureToken {
    mapping(address => uint256) public balances;

    function transfer(address to, uint256 amount) external {
        require(balances[msg.sender] >= amount, "insufficient");
        balances[msg.sender] -= amount; // 内置检查：下溢会revert
        balances[to] += amount; // 内置检查：上溢会revert
    }
}
```

额外建议：对于旧版本，使用OpenZeppelin的`SafeMath`库（如`balances[msg.sender] = balances[msg.sender].sub(amount)`）；始终审计数学运算，并使用有界类型（如`uint128`）减少风险

---

## 不安全类型转换（Unsafe Casting）

### 简要概述
Solidity中进行类型转换时（如从较大类型`uint256`到较小类型`uint8`），若值超出目标类型范围，会发生隐式截断（truncation）或溢出，导致数据丢失、意外行为或安全漏洞，如余额计算错误或权限绕过。Solidity不默认检查转换安全，易被利用。

**典型易受攻击模式**：

```solidity
// 错误示范（无安全检查）
pragma solidity ^0.8.0;

contract VulnerableVault {
    mapping(address => uint256) public balances;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint8 amount) external { // uint8 仅0-255
        require(balances[msg.sender] >= amount);
        balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount); // <-- 若amount实际>255，转换截断导致少转账
    }
}
```

攻击者传入>255的值，转换截断成小值，导致实际提取远超预期（但余额扣除完整值）

### 改进方法
使用显式检查范围或OpenZeppelin的`SafeCast`库，确保转换安全；优先使用足够大的类型避免转换。

示例：
```solidity
// 使用SafeCast
pragma solidity ^0.8.0;
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

contract SecureVault {
    using SafeCast for uint256;
    mapping(address => uint256) public balances;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint256 amount) external {
        require(balances[msg.sender] >= amount, "insufficient");
        balances[msg.sender] -= amount;
        uint8 safeAmount = amount.toUint8(); // <-- 若溢出，会revert
        payable(msg.sender).transfer(safeAmount);
    }
}
```

额外建议：避免不必要转换；使用`require`手动检查（如`require(amount <= type(uint8).max)`）；审计所有类型转换点，优先用相同大小类型

---

## 重入攻击（Re-entrancy）

### 简要描述
合约在进行外部调用（例如 `call`/`transfer`/`send`）后，**在更新自身状态之前**被攻击者合约再次调用该合约的敏感函数，导致状态以为只执行一次但实际上被重复利用，从而盗取资金或破坏逻辑

**典型模式（易受攻击）**：

```solidity
// 错误示范（先外部调用，后更新状态）
function withdraw(uint amount) external {
    require(balances[msg.sender] >= amount);
    (bool ok, ) = msg.sender.call{value: amount}("");
    require(ok);
    balances[msg.sender] -= amount; // <-- 状态更新在外部调用之后（易被重入）
}
```

当 `msg.sender` 是一个恶意合约时，它可以在 `call` 执行时的 `receive()` / `fallback()` 中再次调用 `withdraw`，因为 `balances[msg.sender]` 还没被更新，从而重复提取 ( 最后一次提取不能大于被攻击合约余额, 否则导致 revert, 攻击被回滚 )

---

### 改进方法
编码遵循 `CEI` 模式:
1. Checks（检查）：验证条件、权限、余额等

2. Effects（状态更新）：修改合约状态

3. Interactions（外部交互）：最后才调用外部合约或发送 ETH

示例: 
```solidity
function withdraw(uint256 amount) external {
    // Checks（检查）
    require(balances[msg.sender] >= amount, "insufficient");

    // Effects（先改状态）
    balances[msg.sender] -= amount;

    // Interactions（再外部交互）
    (bool ok, ) = msg.sender.call{value: amount}("");
    require(ok, "send failed");
}
```
---


## 拒绝服务 ( Dos - Denial of Service ) 

### 简要概述

DoS 攻击在智能合约中常出现于以下场景：

> **攻击者通过让某个必要操作持续失败，从而阻止整个合约继续执行关键流程（如奖励分发、批量提款、循环遍历列表等）。**

一个典型案例：
合约在循环中向所有参与者发送 ETH，攻击者故意将自己的 fallback/receive 函数设计为 **永远 revert**，导致程序在遍历到攻击者地址时整个交易回滚，进而导致奖励分发/提款功能长期瘫痪

易受攻击模式：

```solidity
function distribute() external {
    for (uint256 i = 0; i < participants.length; i++) {
        address user = participants[i];
        uint256 amount = rewards[user];

        // 任意一次 transfer 失败，整个分发流程就会 revert
        payable(user).transfer(amount);
    }
}
```

攻击者只需在列表中占据一个位置，即可长期阻塞整个流程。

---

### 改进方法

#### 1）使用 Pull Payment

不再向用户“发送奖励”，而是让用户自己来“领取奖励”，这样单个用户的失败不会影响其他用户

```solidity
function claim() external {
    uint256 amount = rewards[msg.sender];
    require(amount > 0, "no reward");

    // Effects（先修改状态）
    rewards[msg.sender] = 0;

    // Interactions（再转账）
    (bool ok, ) = payable(msg.sender).call{value: amount}("");
    require(ok, "send failed");
}
```

CEI 说明：

* Checks：检查 reward 是否大于 0
* Effects：先清零 reward 防止重入
* Interactions：最后转账，不会阻塞其他用户

---

#### 2）在必须 push 的场景中采用“非阻塞式分发”

避免因为某个地址转账失败而导致整个循环回滚

```solidity
function distribute() external {
    for (uint256 i = 0; i < participants.length; i++) {
        address user = participants[i];
        uint256 amount = rewards[user];

        (bool ok, ) = payable(user).call{value: amount}("");

        if (!ok) {
            // 可记录失败用户，稍后单独处理
            // 不阻塞整体流程
        }
    }
}
```

---


## 弱随机性（Weak Randomness）

### 简要描述

在智能合约中，开发者常会使用一些“看起来随机”的链上变量作为随机数，例如：

* `block.timestamp`
* `block.number`
* `block.coinbase`
* `blockhash`
* `msg.sender`
* `tx.origin`
* `block.prevrandao`（实际上较难预测，但在部分情况下仍能被矿工影响）

这些值**都不能提供真正的不可预测随机性**：

* **攻击者** 可以预测这些值，从而提前知道合约“随机结果”
* **矿工/验证者** 能影响部分变量，例如：选择时间戳、选择出块顺序、决定 blockhash 是否上链

因此攻击者常利用弱随机性提前预测某些结果，从而操纵开奖、战斗判定、NFT 稀有度、博彩结果等。

**典型弱随机性示例：**

```solidity
// 错误示范（弱随机）
// block.timestamp 与 block.number 都可预测
function getRandomNumber() internal view returns (uint256) {
    return uint256(keccak256(abi.encodePacked(
        block.timestamp,
        msg.sender,
        block.number
    )));
}
```

攻击者可以：

* 不断尝试调用直到随机结果符合预期
* 在同一区块内执行“先预测再决定是否提交”
* 利用矿工控制部分区块字段影响结果



### 改进方法

避免使用任何链上可预测变量作为随机源，应采用更安全的随机性方案：


#### **1. 使用预言机（例如 Chainlink VRF）**

Chainlink VRF 提供**可验证、无法操控的随机数**，业界最常用。

```solidity
// 安全：使用 Chainlink VRF 作为随机数
uint256 public randomResult;

function fulfillRandomWords(uint256, uint256[] memory randomWords) internal override {
    randomResult = randomWords[0];
}
```

优点：不可预测、不可操控
缺点：需要预言机费用，非即时（异步）



#### **2. Commit-Reveal（承诺-揭示）模式**

让用户先提交一个哈希（commit），之后再公布原值（reveal），使得结果不能提前被操控。

```solidity
// 安全示例：commit-reveal
mapping(address => bytes32) public commitments;

function commitHash(bytes32 hash) external {
    commitments[msg.sender] = hash;
}

function reveal(uint256 secret) external {
    require(keccak256(abi.encodePacked(secret)) == commitments[msg.sender]);
}
```


#### **3. 使用更安全的随机性聚合（VRF + 用户参与）**

在高安全场景中，可以组合：

* VRF
* 用户提交的 entropy
* 多签随机性

从而获得更强弹性随机性。

---




